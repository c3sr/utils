// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

//go:generate go get github.com/cheekybits/genny

package utils

import (
	"reflect"

	"github.com/k0kubun/pp"
	"github.com/pkg/errors"
)

func FlattenIntSlice(data interface{}) []int {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(int); ok {
			return []int{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []int{int(1)}
			}
			return []int{int(0)}
		case int:
			return []int{int(s)}
		case uint:
			return []int{int(s)}
		case int8:
			return []int{int(s)}
		case uint8:
			return []int{int(s)}
		case int16:
			return []int{int(s)}
		case uint16:
			return []int{int(s)}
		case int32:
			return []int{int(s)}
		case uint32:
			return []int{int(s)}
		case int64:
			return []int{int(s)}
		case uint64:
			return []int{int(s)}
		case float32:
			return []int{int(s)}
		case float64:
			return []int{int(s)}
		case uintptr:
			return []int{int(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []int{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenIntSlice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUintSlice(data interface{}) []uint {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uint); ok {
			return []uint{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uint{uint(1)}
			}
			return []uint{uint(0)}
		case int:
			return []uint{uint(s)}
		case uint:
			return []uint{uint(s)}
		case int8:
			return []uint{uint(s)}
		case uint8:
			return []uint{uint(s)}
		case int16:
			return []uint{uint(s)}
		case uint16:
			return []uint{uint(s)}
		case int32:
			return []uint{uint(s)}
		case uint32:
			return []uint{uint(s)}
		case int64:
			return []uint{uint(s)}
		case uint64:
			return []uint{uint(s)}
		case float32:
			return []uint{uint(s)}
		case float64:
			return []uint{uint(s)}
		case uintptr:
			return []uint{uint(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uint{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUintSlice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUintptrSlice(data interface{}) []uintptr {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uintptr); ok {
			return []uintptr{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uintptr{uintptr(1)}
			}
			return []uintptr{uintptr(0)}
		case int:
			return []uintptr{uintptr(s)}
		case uint:
			return []uintptr{uintptr(s)}
		case int8:
			return []uintptr{uintptr(s)}
		case uint8:
			return []uintptr{uintptr(s)}
		case int16:
			return []uintptr{uintptr(s)}
		case uint16:
			return []uintptr{uintptr(s)}
		case int32:
			return []uintptr{uintptr(s)}
		case uint32:
			return []uintptr{uintptr(s)}
		case int64:
			return []uintptr{uintptr(s)}
		case uint64:
			return []uintptr{uintptr(s)}
		case float32:
			return []uintptr{uintptr(s)}
		case float64:
			return []uintptr{uintptr(s)}
		case uintptr:
			return []uintptr{uintptr(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uintptr{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUintptrSlice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUint8Slice(data interface{}) []uint8 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uint8); ok {
			return []uint8{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uint8{uint8(1)}
			}
			return []uint8{uint8(0)}
		case int:
			return []uint8{uint8(s)}
		case uint:
			return []uint8{uint8(s)}
		case int8:
			return []uint8{uint8(s)}
		case uint8:
			return []uint8{uint8(s)}
		case int16:
			return []uint8{uint8(s)}
		case uint16:
			return []uint8{uint8(s)}
		case int32:
			return []uint8{uint8(s)}
		case uint32:
			return []uint8{uint8(s)}
		case int64:
			return []uint8{uint8(s)}
		case uint64:
			return []uint8{uint8(s)}
		case float32:
			return []uint8{uint8(s)}
		case float64:
			return []uint8{uint8(s)}
		case uintptr:
			return []uint8{uint8(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uint8{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUint8Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUint16Slice(data interface{}) []uint16 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uint16); ok {
			return []uint16{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uint16{uint16(1)}
			}
			return []uint16{uint16(0)}
		case int:
			return []uint16{uint16(s)}
		case uint:
			return []uint16{uint16(s)}
		case int8:
			return []uint16{uint16(s)}
		case uint8:
			return []uint16{uint16(s)}
		case int16:
			return []uint16{uint16(s)}
		case uint16:
			return []uint16{uint16(s)}
		case int32:
			return []uint16{uint16(s)}
		case uint32:
			return []uint16{uint16(s)}
		case int64:
			return []uint16{uint16(s)}
		case uint64:
			return []uint16{uint16(s)}
		case float32:
			return []uint16{uint16(s)}
		case float64:
			return []uint16{uint16(s)}
		case uintptr:
			return []uint16{uint16(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uint16{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUint16Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUint32Slice(data interface{}) []uint32 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uint32); ok {
			return []uint32{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uint32{uint32(1)}
			}
			return []uint32{uint32(0)}
		case int:
			return []uint32{uint32(s)}
		case uint:
			return []uint32{uint32(s)}
		case int8:
			return []uint32{uint32(s)}
		case uint8:
			return []uint32{uint32(s)}
		case int16:
			return []uint32{uint32(s)}
		case uint16:
			return []uint32{uint32(s)}
		case int32:
			return []uint32{uint32(s)}
		case uint32:
			return []uint32{uint32(s)}
		case int64:
			return []uint32{uint32(s)}
		case uint64:
			return []uint32{uint32(s)}
		case float32:
			return []uint32{uint32(s)}
		case float64:
			return []uint32{uint32(s)}
		case uintptr:
			return []uint32{uint32(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uint32{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUint32Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenUint64Slice(data interface{}) []uint64 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(uint64); ok {
			return []uint64{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []uint64{uint64(1)}
			}
			return []uint64{uint64(0)}
		case int:
			return []uint64{uint64(s)}
		case uint:
			return []uint64{uint64(s)}
		case int8:
			return []uint64{uint64(s)}
		case uint8:
			return []uint64{uint64(s)}
		case int16:
			return []uint64{uint64(s)}
		case uint16:
			return []uint64{uint64(s)}
		case int32:
			return []uint64{uint64(s)}
		case uint32:
			return []uint64{uint64(s)}
		case int64:
			return []uint64{uint64(s)}
		case uint64:
			return []uint64{uint64(s)}
		case float32:
			return []uint64{uint64(s)}
		case float64:
			return []uint64{uint64(s)}
		case uintptr:
			return []uint64{uint64(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []uint64{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenUint64Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenInt8Slice(data interface{}) []int8 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(int8); ok {
			return []int8{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []int8{int8(1)}
			}
			return []int8{int8(0)}
		case int:
			return []int8{int8(s)}
		case uint:
			return []int8{int8(s)}
		case int8:
			return []int8{int8(s)}
		case uint8:
			return []int8{int8(s)}
		case int16:
			return []int8{int8(s)}
		case uint16:
			return []int8{int8(s)}
		case int32:
			return []int8{int8(s)}
		case uint32:
			return []int8{int8(s)}
		case int64:
			return []int8{int8(s)}
		case uint64:
			return []int8{int8(s)}
		case float32:
			return []int8{int8(s)}
		case float64:
			return []int8{int8(s)}
		case uintptr:
			return []int8{int8(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []int8{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenInt8Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenInt16Slice(data interface{}) []int16 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(int16); ok {
			return []int16{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []int16{int16(1)}
			}
			return []int16{int16(0)}
		case int:
			return []int16{int16(s)}
		case uint:
			return []int16{int16(s)}
		case int8:
			return []int16{int16(s)}
		case uint8:
			return []int16{int16(s)}
		case int16:
			return []int16{int16(s)}
		case uint16:
			return []int16{int16(s)}
		case int32:
			return []int16{int16(s)}
		case uint32:
			return []int16{int16(s)}
		case int64:
			return []int16{int16(s)}
		case uint64:
			return []int16{int16(s)}
		case float32:
			return []int16{int16(s)}
		case float64:
			return []int16{int16(s)}
		case uintptr:
			return []int16{int16(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []int16{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenInt16Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenInt32Slice(data interface{}) []int32 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(int32); ok {
			return []int32{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []int32{int32(1)}
			}
			return []int32{int32(0)}
		case int:
			return []int32{int32(s)}
		case uint:
			return []int32{int32(s)}
		case int8:
			return []int32{int32(s)}
		case uint8:
			return []int32{int32(s)}
		case int16:
			return []int32{int32(s)}
		case uint16:
			return []int32{int32(s)}
		case int32:
			return []int32{int32(s)}
		case uint32:
			return []int32{int32(s)}
		case int64:
			return []int32{int32(s)}
		case uint64:
			return []int32{int32(s)}
		case float32:
			return []int32{int32(s)}
		case float64:
			return []int32{int32(s)}
		case uintptr:
			return []int32{int32(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []int32{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenInt32Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenInt64Slice(data interface{}) []int64 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(int64); ok {
			return []int64{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []int64{int64(1)}
			}
			return []int64{int64(0)}
		case int:
			return []int64{int64(s)}
		case uint:
			return []int64{int64(s)}
		case int8:
			return []int64{int64(s)}
		case uint8:
			return []int64{int64(s)}
		case int16:
			return []int64{int64(s)}
		case uint16:
			return []int64{int64(s)}
		case int32:
			return []int64{int64(s)}
		case uint32:
			return []int64{int64(s)}
		case int64:
			return []int64{int64(s)}
		case uint64:
			return []int64{int64(s)}
		case float32:
			return []int64{int64(s)}
		case float64:
			return []int64{int64(s)}
		case uintptr:
			return []int64{int64(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []int64{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenInt64Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenFloat32Slice(data interface{}) []float32 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(float32); ok {
			return []float32{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []float32{float32(1)}
			}
			return []float32{float32(0)}
		case int:
			return []float32{float32(s)}
		case uint:
			return []float32{float32(s)}
		case int8:
			return []float32{float32(s)}
		case uint8:
			return []float32{float32(s)}
		case int16:
			return []float32{float32(s)}
		case uint16:
			return []float32{float32(s)}
		case int32:
			return []float32{float32(s)}
		case uint32:
			return []float32{float32(s)}
		case int64:
			return []float32{float32(s)}
		case uint64:
			return []float32{float32(s)}
		case float32:
			return []float32{float32(s)}
		case float64:
			return []float32{float32(s)}
		case uintptr:
			return []float32{float32(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []float32{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenFloat32Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}

//go:generate go get github.com/cheekybits/genny

func FlattenFloat64Slice(data interface{}) []float64 {
	// when data is a scalar
	rval := reflect.ValueOf(data)
	typ := rval.Type()
	if typ.Kind() != reflect.Array &&
		typ.Kind() != reflect.Slice &&
		typ.Kind() != reflect.Interface {
		ddata := indirect(data)
		if e, ok := ddata.(float64); ok {
			return []float64{e}
		}
		switch s := ddata.(type) {
		case bool:
			if s {
				return []float64{float64(1)}
			}
			return []float64{float64(0)}
		case int:
			return []float64{float64(s)}
		case uint:
			return []float64{float64(s)}
		case int8:
			return []float64{float64(s)}
		case uint8:
			return []float64{float64(s)}
		case int16:
			return []float64{float64(s)}
		case uint16:
			return []float64{float64(s)}
		case int32:
			return []float64{float64(s)}
		case uint32:
			return []float64{float64(s)}
		case int64:
			return []float64{float64(s)}
		case uint64:
			return []float64{float64(s)}
		case float32:
			return []float64{float64(s)}
		case float64:
			return []float64{float64(s)}
		case uintptr:
			return []float64{float64(s)}
		}
		panic(errors.Errorf("unable to convert %v of kind %v", pp.Sprint(data), typ.Kind().String()))
	}

	// no we know data is a slice
	res := []float64{}
	for ii := 0; ii < rval.Len(); ii++ {
		val := rval.Index(ii)
		fval := FlattenFloat64Slice(val.Interface())
		res = append(res, fval...)
	}
	return res
}
